import { ethers, } from 'ethers'
import { toast } from 'sonner'
import { useAccount, } from 'wagmi'
import * as divvi from '@divvi/referral-sdk'
import { appAddresses } from '../../lib/const'
import { logger } from '../../lib/utils'
import { IPayWith } from './tokens'
import { useProvider } from '../../hooks/useProvider'
import { ChainName } from './chains'


export interface ISendTxnError {
  code: string
  action: string
  data: string
  reason: string
  transaction: Transaction
  invocation: any
  revert: Revert
  shortMessage: string
  info: Info
}

interface Transaction {
  to: string
  data: string
  from: string
}

interface Revert {
  signature: string
  name: string
  args: string[]
}

interface Info {
  error: Error
  payload: Payload
}

interface Error {
  code: number
  data: Data
  message: string
}

interface Data {
  code: number
  message: string
  data: string
  cause: any
}

interface Payload {
  method: string
  params: Param[]
  id: number
  jsonrpc: string
}

interface Param {
  from: string
  to: string
  data: string
}


const ERC20_ABI = ['function transfer(address recipient, uint256 amount) public returns (bool)']


export function useSendToken() {
  const { address, } = useAccount();
  const provider = useProvider()


  const sendErc20 = async (props: { recipient: string; amount: string; payWith: IPayWith }) => {
    const chain = props.payWith.chain
    const activeProvider = chain.name === ChainName.Base ? provider.base : provider.celo;


    const signer = await activeProvider.getSigner()


    if (!signer) {
      toast.error('Please connect your wallet')
      throw new Error('Signer needed')
    }


    const token = props.payWith.token
    const contract = new ethers.Contract(
      token.address,
      ERC20_ABI,
      signer
    )
    try {
      // // ! Start Divvi
      const transferData = contract.interface.encodeFunctionData("transfer", [
        props.recipient,
        ethers.parseUnits(props.amount, token.decimal),
      ]);

      // Generate Divvi referral tag
      const dataSuffix = divvi.getReferralTag({
        user: address!, // The user address making the transaction
        consumer: appAddresses.divvi as `0x${string}`, // Your Divvi consumer address
      })

      // Append Divvi suffix to transaction data
      let dataWithSuffix = transferData;
      //  const txData = transferData + dataSuffix;
      // const txData = transferData + ethers.hexlify(ethers.toUtf8Bytes(dataSuffix)).slice(2);

      if (dataSuffix && dataSuffix.startsWith('0x')) {
        // Remove '0x' prefix from suffix before concatenating
        dataWithSuffix = transferData + dataSuffix.slice(2);
      } else if (dataSuffix) {
        dataWithSuffix = transferData + dataSuffix;
      }

      // // Send transaction
      const txn = await signer.sendTransaction({
        to: token.address,
        data: dataWithSuffix,
      });

      logger.info(`Transaction successful: ${txn.hash}`)

      await divvi.submitReferral({
        txHash: txn.hash as `0x${string}`,
        chainId: chain.chainId
      });
      logger.info("Referral submitted successfully");
      return JSON.stringify(txn.hash)
    } catch (e) {
      console.log("Transfer Error", e)
      return "Failed!"
    }
    // // ! End Divvi

  }

  return { sendErc20, }
}

